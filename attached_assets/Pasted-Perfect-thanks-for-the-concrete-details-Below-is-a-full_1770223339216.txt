Perfect ‚Äî thanks for the concrete details.
Below is a fully adapted, JWT-native implementation that fits your exact auth + Drizzle schemas. No architectural changes, no session cookies, no hand-waving.

I‚Äôll cover only what changes from my earlier blueprint and give you drop-in code.

0Ô∏è‚É£ Mental model (aligned to your setup)

You have:

JWT access token (Bearer)

refreshTokens table

userSessions table = active sessions + force logout

sessionVersion already exists (‚úî good)

tenantStaff.sessionVersion for staff-level invalidation

SOC2 auditLogs table already defined

stepUpChallenges table already defined

So:

JWT does NOT store session state

Every request must validate:

token

sessionVersion

session not revoked

1Ô∏è‚É£ Active Sessions ‚Äî JWT-compatible implementation
1.1 Create session on login (no cookies)
On successful login (access + refresh issued)
// server/auth/onLoginSuccess.ts
import { db } from "@/server/db";
import { userSessions } from "@/server/db/schema/userSessions";

export async function createUserSession({
  tenantId,
  userId,
  staffId,
  sessionVersion,
  ipAddress,
  userAgent,
  deviceFingerprint,
}: {
  tenantId: string;
  userId: string;
  staffId?: string;
  sessionVersion: number;
  ipAddress?: string;
  userAgent?: string;
  deviceFingerprint?: string;
}) {
  const [session] = await db.insert(userSessions).values({
    tenantId,
    userId,
    staffId,
    sessionVersion,
    ipAddress,
    userAgent,
    deviceFingerprint,
    isCurrent: true,
  }).returning({ id: userSessions.id });

  return session.id;
}


üëâ Important
Include sessionId inside your JWT payload:

// DecodedToken
{
  userId,
  tenantId,
  staffId,
  sessionId,
  sessionVersion
}

1.2 Verify session on every request (middleware)
server/core/auth-middleware.ts (extended)
import { db } from "@/server/db";
import { userSessions } from "@/server/db/schema/userSessions";
import { and, eq, isNull } from "drizzle-orm";

export async function authMiddleware(req, res, next) {
  const authHeader = req.headers.authorization;
  if (!authHeader?.startsWith("Bearer ")) {
    return res.status(401).json({ error: "Missing token" });
  }

  const token = authHeader.slice(7);
  const decoded = await jwtAuthService.verifyAccessToken(token);

  const {
    userId,
    tenantId,
    staffId,
    sessionId,
    sessionVersion,
  } = decoded;

  // üîí Validate session
  const session = await db.query.userSessions.findFirst({
    where: and(
      eq(userSessions.id, sessionId),
      eq(userSessions.tenantId, tenantId),
      isNull(userSessions.revokedAt),
    ),
  });

  if (!session) {
    return res.status(401).json({ error: "Session revoked" });
  }

  if (session.sessionVersion !== sessionVersion) {
    return res.status(401).json({ error: "Session invalidated" });
  }

  // Touch lastSeenAt (throttled recommended)
  await db.update(userSessions)
    .set({ lastSeenAt: new Date() })
    .where(eq(userSessions.id, sessionId));

  req.tokenPayload = decoded;
  req.session = session; // for later use
  next();
}

1.3 List active sessions (fits your schema)
// GET /api/security/sessions
router.get("/security/sessions", async (req, res) => {
  const { userId, tenantId, sessionId } = req.tokenPayload;

  const sessions = await db.query.userSessions.findMany({
    where: and(
      eq(userSessions.tenantId, tenantId),
      eq(userSessions.userId, userId),
    ),
    orderBy: (s, { desc }) => [desc(s.lastSeenAt)],
  });

  res.json({
    sessions,
    currentSessionId: sessionId,
  });
});

1.4 Revoke ONE session (JWT-safe)
// POST /api/security/sessions/:id/revoke
router.post(
  "/security/sessions/:id/revoke",
  requireStepUp("revoke_session"),
  async (req, res) => {
    const { id } = req.params;
    const { userId, tenantId } = req.tokenPayload;

    const session = await db.query.userSessions.findFirst({
      where: eq(userSessions.id, id),
    });

    if (!session || session.tenantId !== tenantId) {
      return res.status(404).json({ error: "Not found" });
    }

    // Only self OR security admin (permission already checked upstream)
    if (session.userId !== userId && !req.user.permissions.includes("SETTINGS_SECURITY_EDIT")) {
      return res.status(403).json({ error: "Forbidden" });
    }

    await db.update(userSessions)
      .set({
        revokedAt: new Date(),
        revokeReason: "manual",
        revokedBy: userId,
      })
      .where(eq(userSessions.id, id));

    await logAudit({
      tenantId,
      userId,
      action: "SESSION_REVOKED",
      resource: "session",
      resourceId: id,
      metadata: { revokedUserId: session.userId },
      ipAddress: req.ip,
      userAgent: req.headers["user-agent"],
    });

    res.json({ success: true });
  }
);

1.5 Revoke ALL sessions (force logout)
This already matches your architecture perfectly
// POST /api/security/force-logout/:userId
router.post(
  "/security/force-logout/:userId",
  requireStepUp("force_logout"),
  async (req, res) => {
    const targetUserId = req.params.userId;
    const { tenantId, userId } = req.tokenPayload;

    // bump staff or user sessionVersion
    await db.update(tenantStaff)
      .set({ sessionVersion: sql`${tenantStaff.sessionVersion} + 1` })
      .where(eq(tenantStaff.userId, targetUserId));

    await logAudit({
      tenantId,
      userId,
      action: "SESSION_INVALIDATED",
      resource: "user",
      resourceId: targetUserId,
    });

    res.json({ success: true });
  }
);

2Ô∏è‚É£ Step-up OTP (TOTP) ‚Äî perfectly aligned

You already have everything needed. Only glue code below.

2.1 Step-up verification (unchanged schema)
// POST /api/security/step-up/verify
import { authenticator } from "otplib";

router.post("/security/step-up/verify", async (req, res) => {
  const { code, purpose } = req.body;
  const { userId, tenantId } = req.tokenPayload;

  const user = await db.query.users.findFirst({ where: eq(users.id, userId) });
  if (!user?.totpSecret) {
    return res.status(400).json({ error: "TOTP_NOT_ENABLED" });
  }

  if (!authenticator.check(code, user.totpSecret)) {
    await logAudit({
      tenantId,
      userId,
      action: "STEP_UP_VERIFIED",
      resource: "security",
      metadata: { purpose, result: "invalid_otp" },
    });
    return res.status(400).json({ error: "INVALID_OTP" });
  }

  await db.insert(stepUpChallenges).values({
    tenantId,
    userId,
    purpose,
    verifiedAt: new Date(),
    expiresAt: new Date(Date.now() + 10 * 60 * 1000),
    ipAddress: req.ip,
    userAgent: req.headers["user-agent"],
  });

  await logAudit({
    tenantId,
    userId,
    action: "STEP_UP_VERIFIED",
    resource: "security",
    metadata: { purpose },
  });

  res.json({ success: true });
});

2.2 Step-up middleware (perfect match)
export function requireStepUp(purpose: StepUpPurpose, windowSec = 600) {
  return async (req, res, next) => {
    const { userId, tenantId } = req.tokenPayload;

    const valid = await db.query.stepUpChallenges.findFirst({
      where: and(
        eq(stepUpChallenges.userId, userId),
        eq(stepUpChallenges.tenantId, tenantId),
        eq(stepUpChallenges.purpose, purpose),
        gt(stepUpChallenges.expiresAt, new Date()),
        isNotNull(stepUpChallenges.verifiedAt)
      ),
    });

    if (!valid) {
      return res.status(428).json({ error: "STEP_UP_REQUIRED", purpose });
    }
    next();
  };
}

3Ô∏è‚É£ Impersonation (JWT-safe, auditable)
3.1 How impersonation works in your system

New JWT is issued

Contains:

actingStaffId

realUserId

Permissions resolved from acting staff

Audit logs always store realUserId

3.2 Start impersonation
// POST /api/security/impersonate/:staffId
router.post(
  "/security/impersonate/:staffId",
  requireStepUp("impersonate"),
  async (req, res) => {
    const { staffId } = req.params;
    const { userId, tenantId } = req.tokenPayload;

    const staff = await db.query.tenantStaff.findFirst({
      where: eq(tenantStaff.id, staffId),
    });

    if (!staff || staff.tenantId !== tenantId) {
      return res.status(404).json({ error: "Staff not found" });
    }

    // issue NEW JWT
    const impersonationToken = await jwtAuthService.signAccessToken({
      userId,
      tenantId,
      staffId: staff.id,
      realUserId: userId,
      impersonating: true,
      sessionVersion: staff.sessionVersion,
    });

    await logAudit({
      tenantId,
      userId,
      action: "IMPERSONATION_STARTED",
      resource: "tenant_staff",
      resourceId: staffId,
    });

    res.json({ accessToken: impersonationToken });
  }
);

Exit impersonation = re-issue normal JWT
4Ô∏è‚É£ IP allow / deny rules (step-up protected)

Nothing structural changes ‚Äî just enforce before auth resolution.

// server/middleware/ipRestriction.ts
export async function ipRestriction(req, res, next) {
  const { tenantId } = req.tokenPayload;

  const rules = await getTenantIpRules(tenantId);
  const ip = req.ip;

  if (rules.some(r => r.type === "DENY" && ipMatches(ip, r.cidr))) {
    return res.status(403).json({ error: "IP_BLOCKED" });
  }

  const allowRules = rules.filter(r => r.type === "ALLOW");
  if (allowRules.length && !allowRules.some(r => ipMatches(ip, r.cidr))) {
    return res.status(403).json({ error: "IP_NOT_ALLOWED" });
  }

  next();
}


Wrap create/update/delete IP rules with:

requireStepUp("ip_rule_change")

5Ô∏è‚É£ SOC2 audit ‚Äî using YOUR schema correctly

Your table already matches SOC2 well.
Just standardize usage.

Audit rules you should enforce

Every sensitive endpoint logs exactly one event

Use:

resource

resourceId

oldValue / newValue only for diffs

metadata for context (purpose, IP, impersonation)

Example: role change
await logAudit({
  tenantId,
  userId,
  action: "USER_ROLE_UPDATED",
  resource: "tenant_staff",
  resourceId: staffId,
  oldValue: { role: oldRole },
  newValue: { role: newRole },
});

Example: IP rule change
await logAudit({
  tenantId,
  userId,
  action: "IP_RULE_CREATED",
  resource: "ip_rule",
  resourceId: rule.id,
  newValue: rule,
});

‚úÖ Final guarantees with this setup

JWT + active sessions fully aligned

Force logout works across all devices

Step-up OTP enforced correctly

Impersonation is explicit + auditable

SOC2 audit trail is complete and consistent

No breaking changes to your existing auth