You don’t need my credentials to resolve this. From what you described, the bug is almost certainly this:

What’s happening

You have two auth modes:

SSO/Replit auth → session cookie → GET /api/session (or similar) works

Email/password JWT → tokens in localStorage

…but your route guard / bootstrap “am I logged in?” check is still cookie-based, so after “successful” JWT login, the app immediately runs the cookie session check, sees “not logged in”, and redirects you back to /login.

That perfectly matches: “click sign in → lands back on login page”.

Fix (no guessing, no credentials required)
1) Make the app’s “auth source of truth” support BOTH cookie + JWT
A) Update your auth bootstrap to:

check JWT tokens first (localStorage)

if absent, fall back to cookie session check (SSO)

Pseudo-logic

async function bootstrapAuth() {
  const accessToken = localStorage.getItem("accessToken");
  const refreshToken = localStorage.getItem("refreshToken");

  // 1) JWT mode
  if (accessToken) {
    setAuthHeader(accessToken);              // axios/fetch default header
    const me = await api.get("/api/auth/me"); // JWT-protected endpoint
    if (me.ok) return setUser(me.user);

    // optional: try refresh
    if (refreshToken) {
      const refreshed = await api.post("/api/auth/refresh", { refreshToken });
      if (refreshed.ok) {
        localStorage.setItem("accessToken", refreshed.accessToken);
        setAuthHeader(refreshed.accessToken);
        const me2 = await api.get("/api/auth/me");
        if (me2.ok) return setUser(me2.user);
      }
    }
    // JWT invalid -> clear
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
  }

  // 2) Cookie session mode (SSO)
  const session = await api.get("/api/session"); // or /api/auth/session
  if (session.ok) return setUser(session.user);

  return setUser(null);
}

B) Update your route guard

Guard should rely on authState.isAuthenticated, not “cookie session exists”.

2) Ensure email/password login code actually stores tokens + updates auth state

On the login page, after successful response:

✅ Must do ALL of these:

localStorage.setItem("accessToken", res.accessToken)

localStorage.setItem("refreshToken", res.refreshToken)

set auth header for future requests

call bootstrapAuth() or set user state directly

redirect to the intended page (dashboard), not back to /login

Common mistake: storing tokens but not updating the in-memory auth state, so the app re-renders “logged out” and redirects.

3) Backend must accept JWT on /api/auth/me (or equivalent)

You need a JWT-protected endpoint that returns current user/tenant context, e.g.:

GET /api/auth/me (Authorization: Bearer <accessToken>)

If you only have cookie session endpoints like /api/session, JWT mode will never “look logged in”.

How to verify without a password (fast)
Option A (best): create a temporary test user via Admin

Since you can’t log in as an existing email/password user, do this:

Create a test user + set password (superadmin or internal seed)

Log in once

Confirm:

Network: POST /api/auth/login returns tokens

Storage: tokens appear in localStorage

Next call: GET /api/auth/me returns 200 using Authorization header

Option B: Add one-time debug logs

Add logs in the login handler + auth bootstrap:

In login success: log “tokens stored”

In bootstrap: log which path is used (JWT vs cookie) and why it failed

Remove after fix.

The most likely single-line root cause

Your auth guard probably does something like:

const session = await fetch("/api/session");
if (!session.ok) navigate("/login");


…and it never checks localStorage JWT.

Copy-paste master prompt for your dev/Replit agent
Bug: Email/password login (JWT stored in localStorage) redirects back to /login immediately. SSO login works (cookie session).

Cause: App bootstrap/auth guard only checks cookie session endpoints (/api/session) and ignores JWT tokens in localStorage.

Fix:
1) Update AuthProvider/bootstrap to support BOTH auth modes:
   - If accessToken exists in localStorage: set Authorization header and call GET /api/auth/me.
   - If /me fails and refreshToken exists: call POST /api/auth/refresh, store new accessToken, retry /me.
   - If no JWT tokens: fallback to cookie session check (/api/session) for SSO.
2) Update route guard to rely on AuthProvider state rather than cookie-only session.
3) Ensure login page stores accessToken/refreshToken + updates auth state (call bootstrap or set user) before redirecting.
4) Add regression test:
   - Mock login returns tokens -> expect navigation to dashboard and AuthProvider isAuthenticated true.
