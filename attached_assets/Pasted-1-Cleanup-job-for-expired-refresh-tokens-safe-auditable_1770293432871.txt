1ï¸âƒ£ Cleanup job for expired refresh tokens (safe + auditable)
Goals

Keep refresh_tokens table small

Ensure expired tokens are revoked consistently

Preserve evidence for SOC2 (donâ€™t hard-delete immediately)

1.1 Cleanup policy (recommended)
Token state	Action
expiresAt < now AND not revoked	Mark revoked (session_expired)
Revoked for â‰¥ 30 days	Hard delete
reuse_detected	Keep â‰¥ 90 days (security evidence)
1.2 Cleanup job (cron / worker)
server/jobs/cleanupExpiredRefreshTokens.ts
import { db } from "@/server/db";
import { refreshTokens } from "@/shared/schema";
import { and, eq, lt, isNull } from "drizzle-orm";
import { logAudit } from "@/server/audit/logAudit";

export async function cleanupExpiredRefreshTokens() {
  const now = new Date();

  // 1ï¸âƒ£ Soft-revoke expired but active tokens
  const expired = await db.update(refreshTokens)
    .set({
      isRevoked: true,
      revokedAt: now,
      revokeReason: "session_expired",
    })
    .where(
      and(
        lt(refreshTokens.expiresAt, now),
        eq(refreshTokens.isRevoked, false),
        isNull(refreshTokens.revokedAt)
      )
    )
    .returning({ id: refreshTokens.id, userId: refreshTokens.userId, tenantId: refreshTokens.tenantId });

  for (const row of expired) {
    await logAudit({
      tenantId: row.tenantId,
      userId: row.userId,
      action: "SESSION_INVALIDATED",
      resource: "refresh_token",
      resourceId: row.id,
      metadata: { reason: "expired_cleanup" },
    });
  }

  // 2ï¸âƒ£ Hard delete old revoked tokens (except reuse_detected)
  const HARD_DELETE_AFTER_DAYS = 30;
  const cutoff = new Date(now.getTime() - HARD_DELETE_AFTER_DAYS * 24 * 60 * 60 * 1000);

  await db.delete(refreshTokens).where(
    and(
      lt(refreshTokens.revokedAt, cutoff),
      eq(refreshTokens.revokeReason, "session_expired")
    )
  );
}

How to run it

Cron: every 6â€“12 hours

Or background worker (BullMQ / Cloud scheduler)

This job is SOC2-friendly: no silent deletes, everything is logged.

2ï¸âƒ£ Wire anomaly scoring â†’ step-up enforcement in /auth/refresh

You already have:

computeSessionAnomalyScore

stepUpChallenges

requireStepUp(...)

Now we enforce it directly in refresh.

2.1 Enforcement policy
Score	Action
< 60	Normal refresh
60â€“89	Require step-up OTP
â‰¥ 90	Revoke family + force logout
2.2 Updated /auth/refresh flow (final)
server/routes/authRefresh.ts
router.post("/auth/refresh", async (req, res) => {
  const {
    refreshToken,
    deviceFingerprint,
    deviceInfo,
  } = req.body;

  const ipAddress = req.ip;
  const userAgent = req.headers["user-agent"];

  // 1ï¸âƒ£ Rotate refresh token first (detect reuse early)
  const rotated = await rotateRefreshToken({
    rawToken: refreshToken,
    ipAddress,
    userAgent,
    deviceFingerprint,
    deviceInfo,
  });

  // 2ï¸âƒ£ Compute anomaly score
  const { score, reasons } = await computeSessionAnomalyScore({
    tenantId: rotated.tenantId!,
    userId: rotated.userId,
    staffId: rotated.staffId,
    deviceFingerprint,
    // country/city if you enrich IP
  });

  // 3ï¸âƒ£ High risk â†’ kill session immediately
  if (score >= 90) {
    await logAudit({
      tenantId: rotated.tenantId,
      userId: rotated.userId,
      action: "SUSPICIOUS_LOGIN_DETECTED",
      resource: "session",
      metadata: { score, reasons, level: "critical" },
      ipAddress,
      userAgent,
    });

    return res.status(401).json({
      error: "SESSION_BLOCKED",
      reason: "high_risk_activity",
    });
  }

  // 4ï¸âƒ£ Medium risk â†’ require step-up
  if (score >= 60) {
    await logAudit({
      tenantId: rotated.tenantId,
      userId: rotated.userId,
      action: "STEP_UP_REQUIRED",
      resource: "auth_refresh",
      metadata: { score, reasons },
      ipAddress,
      userAgent,
    });

    return res.status(428).json({
      error: "STEP_UP_REQUIRED",
      purpose: "security_settings",
      score,
      reasons,
    });
  }

  // 5ï¸âƒ£ Issue new access token
  const accessToken = await jwtAuthService.signAccessToken({
    userId: rotated.userId,
    tenantId: rotated.tenantId,
    staffId: rotated.staffId,
    // include sessionId + sessionVersion as usual
  });

  res.json({
    accessToken,
    refreshToken: rotated.newRefreshToken,
  });
});

Frontend behavior

If 428 STEP_UP_REQUIRED â†’ open OTP modal

On OTP success â†’ retry /auth/refresh

This gives you adaptive authentication (SOC2 loves this).

3ï¸âƒ£ Final SOC2 Security Checklist (Auditor-ready)

You can literally paste this into your SOC2 evidence doc.

ğŸ” Authentication & Sessions

 JWT access tokens with short TTL

 Refresh tokens rotated on every use

 Refresh token reuse detection implemented

 Compromised token family revocation

 Active session tracking (user_sessions)

 Force logout via session versioning

 Expired session cleanup job

ğŸ” Token Security

 Refresh tokens stored as SHA-256 hashes

 Unique constraint on token_hash

 Token families (familyId, parentId)

 Reuse detection with security escalation

 Expired tokens revoked automatically

ğŸ§  Adaptive / Step-Up Authentication

 Session anomaly scoring (device, location, concurrency)

 Risk-based OTP enforcement

 High-risk sessions blocked automatically

 Step-up challenges time-bound and audited

ğŸ‘€ Monitoring & Alerts

 Suspicious login detection

 Refresh token reuse alerts

 IP allow / deny rules

 Forced logout on security events

ğŸ•µï¸ Impersonation Controls

 Explicit admin-initiated impersonation

 Cannot impersonate owners

 Clear UI indicator

 Exit impersonation supported

 All impersonation actions audited

ğŸ“œ Audit & Evidence

 Central audit_logs table

 Immutable audit entries

 Actor, resource, before/after values stored

 Correlation IDs supported

 SOC2-friendly export (CSV / JSON)

 Data export actions logged

ğŸ§¹ Operational Hygiene

 Background cleanup jobs

 Indexed hot paths

 Schema + migration parity

 No silent deletes of security data

ğŸ¯ Final verdict

With:

rotation + reuse detection

anomaly-driven step-up

cleanup jobs

full audit coverage

ğŸ‘‰ You are squarely in SOC2 Type I territory, and very close to Type II (process + time).